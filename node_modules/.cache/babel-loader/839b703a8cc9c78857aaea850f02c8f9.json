{"ast":null,"code":"/*!*/\n// Copyright 2014 Splunk, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n(function () {\n  var ET = require(\"elementtree\");\n\n  var url = require(\"url\");\n\n  var utils = require(\"./utils\");\n\n  var Async = require(\"../async\");\n\n  var ValidationDefinition = require(\"./validationdefinition\");\n\n  var InputDefinition = require(\"./inputdefinition\");\n\n  var EventWriter = require(\"./eventwriter\");\n\n  var Scheme = require(\"./scheme\");\n\n  var Service = require(\"../service\");\n\n  var Logger = require(\"./logger\");\n  /**\n   * A base class for implementing modular inputs.\n   *\n   * Subclasses should implement `getScheme` and `streamEvents`,\n   * and optionally `validateInput` if the modular input uses \n   * external validation.\n   * \n   * The `run` function is used to run modular inputs; it typically\n   * should not be overridden.\n   * @class splunkjs.ModularInputs.ModularInput\n   */\n\n\n  function ModularInput() {\n    this._inputDefinition = null;\n    this._service = null;\n  }\n  /**\n   * Handles all the specifics of running a modular input.\n   *\n   * @param {Object} exports An object representing a modular input script.\n   * @param {Array} args A list of command line arguments passed to this script.\n   * @param {Object} eventWriter An `EventWriter` object for writing event.\n   * @param {Object} inputStream A `Stream` object for reading inputs.\n   * @param {Function} callback The function to call after running this script: `(err, status)`.\n   * @function splunkjs.ModularInputs.ModularInput\n   */\n\n\n  ModularInput.runScript = function (exports, args, eventWriter, inputStream, callback) {\n    // Default empty functions for life cycle events, this is mostly used for the unit tests\n    exports.setup = exports.setup || ModularInput.prototype.setup;\n    exports.start = exports.start || ModularInput.prototype.start;\n    exports.end = exports.end || ModularInput.prototype.end;\n    exports.teardown = exports.teardown || ModularInput.prototype.teardown;\n    var that = this; // Resume streams before trying to read their data.\n    // If the inputStream is a TTY, we don't want to open the stream as it will hold the process open.\n\n    if (inputStream.resume && !inputStream.isTTY) {\n      inputStream.resume();\n    }\n\n    var bigBuff = new Buffer(0); // When streaming events...\n\n    if (args.length === 1) {\n      // After waiting 30.5 seconds for input definitions, assume something bad happened\n      var inputDefintionsReceivedTimer = setTimeout(function () {\n        callback(new Error(\"Receiving input definitions prior to streaming timed out.\"), 1);\n      }, 30500); // Listen for data on inputStream.\n\n      inputStream.on(\"data\", function (chunk) {\n        // Chunk will be a Buffer when interacting with Splunk.\n        bigBuff = Buffer.concat([bigBuff, chunk]); // Remove any trailing whitespace.\n\n        var bufferString = bigBuff.toString(\"utf8\", 0, bigBuff.length).trim();\n\n        if (utils.endsWith(bufferString, \"</input>\")) {\n          // If we've received all of the input definitions, clear the timeout timer\n          clearTimeout(inputDefintionsReceivedTimer);\n          var found = InputDefinition.parse(bufferString);\n          exports._inputDefinition = found;\n          that._inputDefinition = found;\n          Async.chain([function (done) {\n            Async.parallelEach(Object.keys(exports._inputDefinition.inputs), function (name, index, doneEach) {\n              var input = exports._inputDefinition.inputs[name];\n              Async.chain([function (innerDone) {\n                exports.start(name, input, innerDone);\n              }, function (innerDone) {\n                exports.streamEvents(name, input, eventWriter, innerDone);\n              }, function (innerDone) {\n                // end() will only be called if streamEvents doesn't fail.\n                exports.end(name, input, innerDone);\n              }], function (innerErr) {\n                doneEach(innerErr, innerErr ? 1 : 0);\n              });\n            }, function (streamErr) {\n              done(streamErr, streamErr ? 1 : 0);\n            });\n          }], function (err) {\n            // Write the closing </stream> tag.\n            if (eventWriter._headerWritten) {\n              eventWriter.close();\n            }\n\n            callback(err, err ? 1 : 0);\n          });\n        }\n      });\n    } // When getting the scheme...\n    else if (args.length >= 2 && args[1].toString().toLowerCase() === \"--scheme\") {\n        var scheme = exports.getScheme();\n\n        if (!scheme) {\n          Logger.fatal(\"\", \"script returned a null scheme.\", eventWriter._err);\n          callback(null, 1);\n        } else {\n          try {\n            eventWriter.writeXMLDocument(scheme.toXML());\n            callback(null, 0);\n          } catch (e) {\n            Logger.fatal(\"\", \"script could not return the scheme, error: \" + e, eventWriter._err);\n            callback(e, 1);\n          }\n        }\n      } // When validating arguments...\n      else if (args.length >= 2 && args[1].toString().toLowerCase() === \"--validate-arguments\") {\n          // After waiting 30.5 seconds for a validation definition, assume something bad happened\n          var validationDefintionReceivedTimer = setTimeout(function () {\n            callback(new Error(\"Receiving validation definition prior to validating timed out.\"), 1);\n          }, 30500); // Listen for data on inputStream.\n\n          inputStream.on(\"data\", function (chunk) {\n            bigBuff = Buffer.concat([bigBuff, chunk]); // Remove any trailing whitespace.\n\n            var bufferString = bigBuff.toString(\"utf8\", 0, bigBuff.length).trim();\n\n            if (utils.endsWith(bufferString, \"</items>\")) {\n              // If we've received all of the validation definition, clear the timeout timer\n              clearTimeout(validationDefintionReceivedTimer);\n              Async.chain([function (done) {\n                try {\n                  // If there is no validateInput method set, accept all input.\n                  if (utils.isUndefined(exports.validateInput)) {\n                    done();\n                  } else {\n                    // If exports.validateInput doesn't throw an error, we assume validation succeeded.\n                    var definition = ValidationDefinition.parse(bigBuff.toString(\"utf8\", 0, bigBuff.length));\n                    exports.validateInput(definition, done);\n                  }\n                } catch (e) {\n                  // If exports.validateInput throws an error, we assume validation failed.\n                  done(e);\n                }\n              }], function (err) {\n                if (err) {\n                  Logger.error(\"\", err.message);\n                  Logger.error(\"\", \"Stack trace for a modular input error: \" + err.stack);\n\n                  try {\n                    var errorRoot = ET.Element(\"error\");\n                    ET.SubElement(errorRoot, \"message\").text = err.message;\n                    eventWriter.writeXMLDocument(errorRoot);\n                    callback(err, 1); // Some error while validating the input.\n                  } catch (e) {\n                    callback(e, 1); // Error trying to write the error.\n                  }\n                } else {\n                  callback(null, 0); // No error\n                }\n              });\n            }\n          });\n        } // When we get unexpected args...\n        else {\n            var msg = \"Invalid arguments to modular input script: \" + args.join() + \"\\n\";\n            Logger.error(\"\", msg, eventWriter._err);\n            callback(msg, 1);\n          }\n  };\n  /**\n   * Returns a `splunkjs.Service` object for this script invocation.\n   *\n   * The service object is created from the Splunkd URI and session key\n   * passed to the command invocation on the modular input stream. It is\n   * available as soon as the `ModularInput.streamEvents` function is called.\n   *\n   * @return {Object} A `Splunkjs.Service` Object, or null if you call this function before the `ModularInput.streamEvents` function is called.\n   * @function splunkjs.ModularInputs.ModularInput\n   */\n\n\n  ModularInput.service = function () {\n    if (this._service) {\n      return this._service;\n    }\n\n    if (!this._inputDefinition) {\n      return null;\n    }\n\n    var splunkdURI = this._inputDefinition.metadata[\"server_uri\"];\n    var sessionKey = this._inputDefinition.metadata[\"session_key\"];\n    var urlParts = url.parse(splunkdURI); // urlParts.protocol will have a trailing colon; remove it.\n\n    var scheme = urlParts.protocol.replace(\":\", \"\");\n    var splunkdHost = urlParts.hostname;\n    var splunkdPort = urlParts.port;\n    this._service = new Service({\n      scheme: scheme,\n      host: splunkdHost,\n      port: splunkdPort,\n      token: sessionKey\n    });\n    return this._service;\n  }; // Default to empty functions for life cycle events.\n\n  /**\n   * Runs before streaming begins.\n   *\n   * @param {Function} done The function to call when done: `(err)`.\n   * @function splunkjs.ModularInputs.ModularInput\n   */\n\n\n  ModularInput.prototype.setup = function (done) {\n    done();\n  };\n  /**\n   * Runs once the streaming starts, for an input.\n   *\n   * @param {String} name The name of this modular input.\n   * @param {Object} definition An InputDefinition object.\n   * @param {Function} done The function to call when done: `(err)`.\n   * @function splunkjs.ModularInputs.ModularInput\n   */\n\n\n  ModularInput.prototype.start = function (name, definition, done) {\n    done();\n  };\n  /**\n   * Runs once the streaming ends, for an input (upon successfully streaming all events).\n   *\n   * @param {String} name The name of this modular input.\n   * @param {Object} definition An InputDefinition object.\n   * @param {Function} done The function to call when done: `(err)`.\n   * @function splunkjs.ModularInputs.ModularInput\n   */\n\n\n  ModularInput.prototype.end = function (name, definition, done) {\n    done();\n  };\n  /**\n   * Runs after all streaming is done for all inputs definitions.\n   *\n   * @param {Function} done The function to call when done: `(err)`.\n   * @function splunkjs.ModularInputs.ModularInput\n   */\n\n\n  ModularInput.prototype.teardown = function (done) {\n    done();\n  };\n\n  module.exports = ModularInput;\n})();","map":{"version":3,"sources":["/Users/cyfi/Downloads/splunk-sdk-javascript-create-react-app/examples/browser/create-splunk-react-app/node_modules/splunk-sdk/lib/modularinputs/modularinput.js"],"names":["ET","require","url","utils","Async","ValidationDefinition","InputDefinition","EventWriter","Scheme","Service","Logger","ModularInput","_inputDefinition","_service","runScript","exports","args","eventWriter","inputStream","callback","setup","prototype","start","end","teardown","that","resume","isTTY","bigBuff","Buffer","length","inputDefintionsReceivedTimer","setTimeout","Error","on","chunk","concat","bufferString","toString","trim","endsWith","clearTimeout","found","parse","chain","done","parallelEach","Object","keys","inputs","name","index","doneEach","input","innerDone","streamEvents","innerErr","streamErr","err","_headerWritten","close","toLowerCase","scheme","getScheme","fatal","_err","writeXMLDocument","toXML","e","validationDefintionReceivedTimer","isUndefined","validateInput","definition","error","message","stack","errorRoot","Element","SubElement","text","msg","join","service","splunkdURI","metadata","sessionKey","urlParts","protocol","replace","splunkdHost","hostname","splunkdPort","port","host","token","module"],"mappings":"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","sourcesContent":["/*!*/\n// Copyright 2014 Splunk, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n(function() {\n    var ET = require(\"elementtree\");\n    var url = require(\"url\");\n    var utils = require(\"./utils\");\n    var Async = require(\"../async\");\n    var ValidationDefinition = require(\"./validationdefinition\");\n    var InputDefinition = require(\"./inputdefinition\");\n    var EventWriter = require(\"./eventwriter\");\n    var Scheme = require(\"./scheme\");\n    var Service = require(\"../service\");\n    var Logger = require(\"./logger\");\n\n    /**\n     * A base class for implementing modular inputs.\n     *\n     * Subclasses should implement `getScheme` and `streamEvents`,\n     * and optionally `validateInput` if the modular input uses \n     * external validation.\n     * \n     * The `run` function is used to run modular inputs; it typically\n     * should not be overridden.\n     * @class splunkjs.ModularInputs.ModularInput\n     */\n    function ModularInput() {\n        this._inputDefinition = null;\n        this._service = null;\n    }\n\n    /**\n     * Handles all the specifics of running a modular input.\n     *\n     * @param {Object} exports An object representing a modular input script.\n     * @param {Array} args A list of command line arguments passed to this script.\n     * @param {Object} eventWriter An `EventWriter` object for writing event.\n     * @param {Object} inputStream A `Stream` object for reading inputs.\n     * @param {Function} callback The function to call after running this script: `(err, status)`.\n     * @function splunkjs.ModularInputs.ModularInput\n     */\n    ModularInput.runScript = function(exports, args, eventWriter, inputStream, callback) {\n        // Default empty functions for life cycle events, this is mostly used for the unit tests\n        exports.setup       = exports.setup     || ModularInput.prototype.setup;\n        exports.start       = exports.start     || ModularInput.prototype.start;\n        exports.end         = exports.end       || ModularInput.prototype.end;\n        exports.teardown    = exports.teardown  || ModularInput.prototype.teardown;\n\n        var that = this;\n\n        // Resume streams before trying to read their data.\n        // If the inputStream is a TTY, we don't want to open the stream as it will hold the process open.\n        if (inputStream.resume && !inputStream.isTTY) {\n            inputStream.resume();\n        }\n        var bigBuff = new Buffer(0);\n\n        // When streaming events...\n        if (args.length === 1) {\n            // After waiting 30.5 seconds for input definitions, assume something bad happened\n            var inputDefintionsReceivedTimer = setTimeout(function() {\n                callback(new Error(\"Receiving input definitions prior to streaming timed out.\"), 1);\n            }, 30500);\n\n            // Listen for data on inputStream.\n            inputStream.on(\"data\", function(chunk) {\n                // Chunk will be a Buffer when interacting with Splunk.\n                bigBuff = Buffer.concat([bigBuff, chunk]);\n\n                // Remove any trailing whitespace.\n                var bufferString = bigBuff.toString(\"utf8\", 0, bigBuff.length).trim();\n                \n                if (utils.endsWith(bufferString, \"</input>\")) {\n                    // If we've received all of the input definitions, clear the timeout timer\n                    clearTimeout(inputDefintionsReceivedTimer);\n\n                    var found = InputDefinition.parse(bufferString);\n                    exports._inputDefinition = found;\n                    that._inputDefinition = found;\n\n                    Async.chain([\n                            function(done) {\n                                Async.parallelEach(\n                                    Object.keys(exports._inputDefinition.inputs),\n                                    function (name, index, doneEach) {\n                                        var input = exports._inputDefinition.inputs[name];\n                                        \n                                        Async.chain([\n                                                function(innerDone) {\n                                                    exports.start(name, input, innerDone);\n                                                },\n                                                function(innerDone) {\n                                                    exports.streamEvents(name, input, eventWriter, innerDone);\n                                                },\n                                                function(innerDone) {\n                                                    // end() will only be called if streamEvents doesn't fail.\n                                                    exports.end(name, input, innerDone);\n                                                }\n                                            ],\n                                            function(innerErr) {\n                                                doneEach(innerErr, innerErr ? 1 : 0);\n                                            }\n                                        );\n                                    }, \n                                    function (streamErr) {\n                                        done(streamErr, streamErr ? 1 : 0);\n                                    }\n                                );\n                            }\n                        ],\n                        function(err) {\n                            // Write the closing </stream> tag.\n                            if (eventWriter._headerWritten) {\n                                eventWriter.close();\n                            }\n                            callback(err, err ? 1 : 0);\n                        }\n                    );\n                }\n            });\n        }\n        // When getting the scheme...\n        else if (args.length >= 2 && args[1].toString().toLowerCase() === \"--scheme\") {\n            var scheme = exports.getScheme();\n\n            if (!scheme) {\n                Logger.fatal(\"\", \"script returned a null scheme.\", eventWriter._err);\n                callback(null, 1);\n            }\n            else {\n                try {\n                    eventWriter.writeXMLDocument(scheme.toXML());\n                    callback(null, 0);\n                }\n                catch (e) {\n                    Logger.fatal(\"\", \"script could not return the scheme, error: \" + e, eventWriter._err);\n                    callback(e, 1);\n                }\n            }\n        }\n        // When validating arguments...\n        else if (args.length >= 2 && args[1].toString().toLowerCase() === \"--validate-arguments\") {\n            // After waiting 30.5 seconds for a validation definition, assume something bad happened\n            var validationDefintionReceivedTimer = setTimeout(function() {\n                callback(new Error(\"Receiving validation definition prior to validating timed out.\"), 1);\n            }, 30500);\n\n            // Listen for data on inputStream.\n            inputStream.on(\"data\", function(chunk) {\n                bigBuff = Buffer.concat([bigBuff, chunk]);\n                \n                // Remove any trailing whitespace.\n                var bufferString = bigBuff.toString(\"utf8\", 0, bigBuff.length).trim();\n\n                if (utils.endsWith(bufferString, \"</items>\")) {\n                    // If we've received all of the validation definition, clear the timeout timer\n                    clearTimeout(validationDefintionReceivedTimer);\n                    Async.chain([\n                            function (done) {\n                                try {\n                                    // If there is no validateInput method set, accept all input.\n                                    if (utils.isUndefined(exports.validateInput)) {\n                                        done();\n                                    }\n                                    else {\n                                        // If exports.validateInput doesn't throw an error, we assume validation succeeded.\n                                        var definition = ValidationDefinition.parse(bigBuff.toString(\"utf8\", 0, bigBuff.length));\n                                        exports.validateInput(definition, done);\n                                    }\n                                }\n                                catch (e) {\n                                    // If exports.validateInput throws an error, we assume validation failed.\n                                    done(e);\n                                }\n                            }\n                        ],\n                        function (err) {\n                            if (err) {\n                                Logger.error(\"\", err.message);\n                                Logger.error(\"\", \"Stack trace for a modular input error: \" + err.stack);\n\n                                try {\n                                    var errorRoot = ET.Element(\"error\");\n                                    ET.SubElement(errorRoot, \"message\").text = err.message;\n                                    eventWriter.writeXMLDocument(errorRoot);\n                                    callback(err, 1); // Some error while validating the input.\n                                }\n                                catch (e) {\n                                    callback(e, 1); // Error trying to write the error.\n                                }\n                            }\n                            else {\n                                callback(null, 0); // No error\n                            }\n                        }\n                    );\n                }\n            });\n        }\n        // When we get unexpected args...\n        else {\n            var msg = \"Invalid arguments to modular input script: \" + args.join() + \"\\n\";\n            Logger.error(\"\", msg, eventWriter._err);\n            callback(msg, 1);\n        }\n    };\n\n    /**\n     * Returns a `splunkjs.Service` object for this script invocation.\n     *\n     * The service object is created from the Splunkd URI and session key\n     * passed to the command invocation on the modular input stream. It is\n     * available as soon as the `ModularInput.streamEvents` function is called.\n     *\n     * @return {Object} A `Splunkjs.Service` Object, or null if you call this function before the `ModularInput.streamEvents` function is called.\n     * @function splunkjs.ModularInputs.ModularInput\n     */\n    ModularInput.service = function() {\n        if (this._service) {\n            return this._service;\n        }\n\n        if (!this._inputDefinition) {\n            return null;\n        }\n\n        var splunkdURI = this._inputDefinition.metadata[\"server_uri\"];\n        var sessionKey = this._inputDefinition.metadata[\"session_key\"];\n\n        var urlParts = url.parse(splunkdURI);\n\n        // urlParts.protocol will have a trailing colon; remove it.\n        var scheme = urlParts.protocol.replace(\":\", \"\");\n        var splunkdHost = urlParts.hostname;\n        var splunkdPort = urlParts.port;\n\n        this._service = new Service({\n            scheme: scheme,\n            host: splunkdHost,\n            port: splunkdPort,\n            token: sessionKey\n        });\n\n        return this._service;\n    };\n\n    // Default to empty functions for life cycle events.\n\n    /**\n     * Runs before streaming begins.\n     *\n     * @param {Function} done The function to call when done: `(err)`.\n     * @function splunkjs.ModularInputs.ModularInput\n     */\n    ModularInput.prototype.setup = function(done) {\n        done();\n    };\n    /**\n     * Runs once the streaming starts, for an input.\n     *\n     * @param {String} name The name of this modular input.\n     * @param {Object} definition An InputDefinition object.\n     * @param {Function} done The function to call when done: `(err)`.\n     * @function splunkjs.ModularInputs.ModularInput\n     */\n    ModularInput.prototype.start = function(name, definition, done) {\n        done();\n    };\n    /**\n     * Runs once the streaming ends, for an input (upon successfully streaming all events).\n     *\n     * @param {String} name The name of this modular input.\n     * @param {Object} definition An InputDefinition object.\n     * @param {Function} done The function to call when done: `(err)`.\n     * @function splunkjs.ModularInputs.ModularInput\n     */\n    ModularInput.prototype.end = function(name, definition, done) {\n        done();\n    };\n    /**\n     * Runs after all streaming is done for all inputs definitions.\n     *\n     * @param {Function} done The function to call when done: `(err)`.\n     * @function splunkjs.ModularInputs.ModularInput\n     */\n    ModularInput.prototype.teardown = function(done) {\n        done();\n    };\n\n    module.exports = ModularInput;\n})();\n"]},"metadata":{},"sourceType":"script"}