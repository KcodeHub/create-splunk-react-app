{"ast":null,"code":"// wrapper for non-node envs\n;\n\n(function (sax) {\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream; // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n  var buffers = [\"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\", \"procInstName\", \"procInstBody\", \"entity\", \"attribName\", \"attribValue\", \"cdata\", \"script\"];\n  sax.EVENTS = // for discoverability.\n  [\"text\", \"processinginstruction\", \"sgmldeclaration\", \"doctype\", \"comment\", \"attribute\", \"opentag\", \"closetag\", \"opencdata\", \"cdata\", \"closecdata\", \"error\", \"end\", \"ready\", \"script\", \"opennamespace\", \"closenamespace\"];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.tagCase = parser.opt.lowercasetags ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.ENTITIES = Object.create(sax.ENTITIES);\n    parser.attribList = []; // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n\n    if (parser.opt.xmlns) parser.ns = Object.create(rootNS); // mostly just for error reporting\n\n    parser.position = parser.line = parser.column = 0;\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) Object.create = function (o) {\n    function f() {\n      this.__proto__ = o;\n    }\n\n    f.prototype = o;\n    return new f();\n  };\n  if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n    return o.__proto__;\n  };\n  if (!Object.keys) Object.keys = function (o) {\n    var a = [];\n\n    for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n\n    return a;\n  };\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10),\n        maxActual = 0;\n\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n\n      maxActual = Math.max(maxActual, len);\n    } // schedule the next check for the earliest possible buffer overrun.\n\n\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH - maxActual + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    },\n    end: function () {\n      return this.write(null);\n    }\n  };\n\n  try {\n    var Stream = require(\"stream\").Stream;\n  } catch (ex) {\n    var Stream = function () {};\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);\n    Stream.apply(me);\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er); // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            return me._parser[\"on\" + ev] = h;\n          }\n\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  });\n\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n\n    this._parser.end();\n\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  }; // character classes and tokens\n\n\n  var whitespace = \"\\r\\n\\t \" // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  ,\n      number = \"0124356789\",\n      letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" // (Letter | \"_\" | \":\")\n  ,\n      nameStart = letter + \"_:\",\n      nameBody = nameStart + number + \"-.\",\n      quote = \"'\\\"\",\n      entity = number + letter + \"#\",\n      attribEnd = whitespace + \">\",\n      CDATA = \"[CDATA[\",\n      DOCTYPE = \"DOCTYPE\",\n      XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\",\n      XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\",\n      rootNS = {\n    xml: XML_NAMESPACE,\n    xmlns: XMLNS_NAMESPACE\n  }; // turn all the string character sets into character class objects.\n\n  whitespace = charClass(whitespace);\n  number = charClass(number);\n  letter = charClass(letter);\n  nameStart = charClass(nameStart);\n  nameBody = charClass(nameBody);\n  quote = charClass(quote);\n  entity = charClass(entity);\n  attribEnd = charClass(attribEnd);\n\n  function charClass(str) {\n    return str.split(\"\").reduce(function (s, c) {\n      s[c] = true;\n      return s;\n    }, {});\n  }\n\n  function is(charclass, c) {\n    return charclass[c];\n  }\n\n  function not(charclass, c) {\n    return !charclass[c];\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++,\n    TEXT: S++ // general stuff\n    ,\n    TEXT_ENTITY: S++ // &amp and such.\n    ,\n    OPEN_WAKA: S++ // <\n    ,\n    SGML_DECL: S++ // <!BLARG\n    ,\n    SGML_DECL_QUOTED: S++ // <!BLARG foo \"bar\n    ,\n    DOCTYPE: S++ // <!DOCTYPE\n    ,\n    DOCTYPE_QUOTED: S++ // <!DOCTYPE \"//blah\n    ,\n    DOCTYPE_DTD: S++ // <!DOCTYPE \"//blah\" [ ...\n    ,\n    DOCTYPE_DTD_QUOTED: S++ // <!DOCTYPE \"//blah\" [ \"foo\n    ,\n    COMMENT_STARTING: S++ // <!-\n    ,\n    COMMENT: S++ // <!--\n    ,\n    COMMENT_ENDING: S++ // <!-- blah -\n    ,\n    COMMENT_ENDED: S++ // <!-- blah --\n    ,\n    CDATA: S++ // <![CDATA[ something\n    ,\n    CDATA_ENDING: S++ // ]\n    ,\n    CDATA_ENDING_2: S++ // ]]\n    ,\n    PROC_INST: S++ // <?hi\n    ,\n    PROC_INST_BODY: S++ // <?hi there\n    ,\n    PROC_INST_QUOTED: S++ // <?hi \"there\n    ,\n    PROC_INST_ENDING: S++ // <?hi \"there\" ?\n    ,\n    OPEN_TAG: S++ // <strong\n    ,\n    OPEN_TAG_SLASH: S++ // <strong /\n    ,\n    ATTRIB: S++ // <a\n    ,\n    ATTRIB_NAME: S++ // <a foo\n    ,\n    ATTRIB_NAME_SAW_WHITE: S++ // <a foo _\n    ,\n    ATTRIB_VALUE: S++ // <a foo=\n    ,\n    ATTRIB_VALUE_QUOTED: S++ // <a foo=\"bar\n    ,\n    ATTRIB_VALUE_UNQUOTED: S++ // <a foo=bar\n    ,\n    ATTRIB_VALUE_ENTITY_Q: S++ // <foo bar=\"&quot;\"\n    ,\n    ATTRIB_VALUE_ENTITY_U: S++ // <foo bar=&quot;\n    ,\n    CLOSE_TAG: S++ // </a\n    ,\n    CLOSE_TAG_SAW_WHITE: S++ // </a   >\n    ,\n    SCRIPT: S++ // <script> ...\n    ,\n    SCRIPT_ENDING: S++ // <script> ... <\n\n  };\n  sax.ENTITIES = {\n    \"apos\": \"'\",\n    \"quot\": \"\\\"\",\n    \"amp\": \"&\",\n    \"gt\": \">\",\n    \"lt\": \"<\"\n  };\n\n  for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S; // shorthand\n\n\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n    er += \"\\nLine: \" + parser.line + \"\\nColumn: \" + parser.column + \"\\nChar: \" + parser.c;\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.TEXT) error(parser, \"Unexpected end\");\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (parser.strict) error(parser, message);\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.tagCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser,\n        tag = parser.tag = {\n      name: parser.tagName,\n      attributes: {}\n    }; // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n\n    if (parser.opt.xmlns) tag.ns = parent.ns;\n    parser.attribList.length = 0;\n  }\n\n  function qname(name) {\n    var i = name.indexOf(\":\"),\n        qualName = i < 0 ? [\"\", name] : name.split(\":\"),\n        prefix = qualName[0],\n        local = qualName[1]; // <x \"xmlns\"=\"http://foo\">\n\n    if (name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return {\n      prefix: prefix,\n      local: local\n    };\n  }\n\n  function attrib(parser) {\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName),\n          prefix = qn.prefix,\n          local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute; push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser, \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser, \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\" + \"Actual: \" + parser.attribValue);\n        } else {\n          var tag = parser.tag,\n              parent = parser.tags[parser.tags.length - 1] || parser;\n\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n\n          tag.ns[local] = parser.attribValue;\n        }\n      } // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect; preserve attribute order\n      // so deferred events can be emitted in document order\n\n\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag; // add namespace info to tag\n\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || qn.prefix;\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName));\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p]\n          });\n        });\n      } // handle deferred onattribute events\n\n\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0],\n            value = nv[1],\n            qualName = qname(name),\n            prefix = qualName.prefix,\n            local = qualName.local,\n            uri = tag.ns[prefix] || \"\",\n            a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }; // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (prefix && prefix != \"xmlns\" && !uri) {\n          strictFail(parser, \"Unbound namespace prefix: \" + JSON.stringify(prefix));\n          a.uri = prefix;\n        }\n\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n\n      parser.attribList.length = 0;\n    } // process the tag\n\n\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    } // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n\n\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) tagName = tagName[parser.tagCase]();\n    var closeTo = tagName;\n\n    while (t--) {\n      var close = parser.tags[t];\n\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else break;\n    } // didn't find it.  we already failed for strict, so just abort.\n\n\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop();\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n      var x = {};\n\n      for (var i in tag.ns) x[i] = tag.ns[i];\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", {\n            prefix: p,\n            uri: n\n          });\n        });\n      }\n    }\n\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity.toLowerCase(),\n        num,\n        numStr = \"\";\n    if (parser.ENTITIES[entity]) return parser.ENTITIES[entity];\n\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n\n    entity = entity.replace(/^0+/, \"\");\n\n    if (numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCharCode(num);\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser, \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0,\n        c = \"\";\n\n    while (parser.c = c = chunk.charAt(i++)) {\n      parser.position++;\n\n      if (c === \"\\n\") {\n        parser.line++;\n        parser.column = 0;\n      } else parser.column++;\n\n      switch (parser.state) {\n        case S.BEGIN:\n          if (c === \"<\") parser.state = S.OPEN_WAKA;else if (not(whitespace, c)) {\n            // have to process this as a text node.\n            // weird, but happens.\n            strictFail(parser, \"Non-whitespace before first tag.\");\n            parser.textNode = c;\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = chunk.charAt(i++);\n\n              if (c) {\n                parser.position++;\n\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else parser.column++;\n              }\n            }\n\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n\n          if (c === \"<\") parser.state = S.OPEN_WAKA;else {\n            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) strictFail(\"Text data outside of root node.\");\n            if (c === \"&\") parser.state = S.TEXT_ENTITY;else parser.textNode += c;\n          }\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else parser.script += c;\n\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            emitNode(parser, \"onscript\", parser.script);\n            parser.state = S.CLOSE_TAG;\n            parser.script = \"\";\n            parser.tagName = \"\";\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (is(whitespace, c)) {// wait for it...\n          } else if (is(nameStart, c)) {\n            parser.startTagPosition = parser.position - 1;\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.startTagPosition = parser.position - 1;\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) strictFail(parser, \"Inappropriately located doctype declaration\");\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (is(quote, c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else parser.sgmlDecl += c;\n\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") parser.state = S.DOCTYPE_DTD;else if (is(quote, c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") parser.state = S.DOCTYPE;else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") parser.state = S.COMMENT_ENDING;else parser.comment += c;\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) emitNode(parser, \"oncomment\", parser.comment);\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\"); // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else parser.state = S.TEXT;\n\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") parser.state = S.CDATA_ENDING;else parser.cdata += c;\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") parser.state = S.CDATA_ENDING_2;else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata);\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") parser.state = S.PROC_INST_ENDING;else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY;else parser.procInstName += c;\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && is(whitespace, c)) continue;else if (c === \"?\") parser.state = S.PROC_INST_ENDING;else if (is(quote, c)) {\n            parser.state = S.PROC_INST_QUOTED;\n            parser.q = c;\n            parser.procInstBody += c;\n          } else parser.procInstBody += c;\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n\n          continue;\n\n        case S.PROC_INST_QUOTED:\n          parser.procInstBody += c;\n\n          if (c === parser.q) {\n            parser.state = S.PROC_INST_BODY;\n            parser.q = \"\";\n          }\n\n          continue;\n\n        case S.OPEN_TAG:\n          if (is(nameBody, c)) parser.tagName += c;else {\n            newTag(parser);\n            if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else {\n              if (not(whitespace, c)) strictFail(parser, \"Invalid character in tag name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Forward-slash in opening tag not followed by >\");\n            parser.state = S.ATTRIB;\n          }\n\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (is(whitespace, c)) continue;else if (c === \">\") openTag(parser);else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH;else if (is(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else strictFail(parser, \"Invalid attribute name\");\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE;else if (is(nameBody, c)) parser.attribName += c;else strictFail(parser, \"Invalid attribute name\");\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") parser.state = S.ATTRIB_VALUE;else if (is(whitespace, c)) continue;else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\"\n            });\n            parser.attribName = \"\";\n            if (c === \">\") openTag(parser);else if (is(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (is(whitespace, c)) continue;else if (is(quote, c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q;else parser.attribValue += c;\n            continue;\n          }\n\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB;\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (not(attribEnd, c)) {\n            if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U;else parser.attribValue += c;\n            continue;\n          }\n\n          attrib(parser);\n          if (c === \">\") openTag(parser);else parser.state = S.ATTRIB;\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (is(whitespace, c)) continue;else if (not(nameStart, c)) strictFail(parser, \"Invalid tagname in closing tag.\");else parser.tagName = c;\n          } else if (c === \">\") closeTag(parser);else if (is(nameBody, c)) parser.tagName += c;else {\n            if (not(whitespace, c)) strictFail(parser, \"Invalid tagname in closing tag\");\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (is(whitespace, c)) continue;\n          if (c === \">\") closeTag(parser);else strictFail(\"Invalid characters in closing tag\");\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              var returnState = S.TEXT,\n                  buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              var returnState = S.ATTRIB_VALUE_QUOTED,\n                  buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              var returnState = S.ATTRIB_VALUE_UNQUOTED,\n                  buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            parser[buffer] += parseEntity(parser);\n            parser.entity = \"\";\n            parser.state = returnState;\n          } else if (is(entity, c)) parser.entity += c;else {\n            strictFail(\"Invalid character entity\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default:\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n      }\n    } // while\n    // cdata blocks can get very big under normal conditions. emit and move on.\n    // if (parser.state === S.CDATA && parser.cdata) {\n    //   emitNode(parser, \"oncdata\", parser.cdata)\n    //   parser.cdata = \"\"\n    // }\n\n\n    if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser);\n    return parser;\n  }\n})(typeof exports === \"undefined\" ? sax = {} : exports);","map":{"version":3,"sources":["/Users/cyfi/Downloads/splunk-sdk-javascript-create-react-app/examples/browser/create-splunk-react-app/node_modules/elementtree/node_modules/sax/lib/sax.js"],"names":["sax","parser","strict","opt","SAXParser","SAXStream","createStream","MAX_BUFFER_LENGTH","buffers","EVENTS","clearBuffers","q","c","bufferCheckPosition","tagCase","lowercasetags","tags","closed","closedRoot","sawRoot","tag","error","noscript","state","S","BEGIN","ENTITIES","Object","create","attribList","xmlns","ns","rootNS","position","line","column","emit","o","f","__proto__","prototype","getPrototypeOf","keys","a","i","hasOwnProperty","push","checkBufferLength","maxAllowed","Math","max","maxActual","l","length","len","closeText","emitNode","cdata","script","end","write","resume","close","Stream","require","ex","streamWraps","filter","ev","apply","me","_parser","writable","readable","onend","onerror","er","forEach","defineProperty","get","set","h","removeAllListeners","on","enumerable","configurable","constructor","value","data","toString","chunk","handler","indexOf","args","arguments","Array","splice","call","whitespace","number","letter","nameStart","nameBody","quote","entity","attribEnd","CDATA","DOCTYPE","XML_NAMESPACE","XMLNS_NAMESPACE","xml","charClass","str","split","reduce","s","is","charclass","not","STATE","TEXT","TEXT_ENTITY","OPEN_WAKA","SGML_DECL","SGML_DECL_QUOTED","DOCTYPE_QUOTED","DOCTYPE_DTD","DOCTYPE_DTD_QUOTED","COMMENT_STARTING","COMMENT","COMMENT_ENDING","COMMENT_ENDED","CDATA_ENDING","CDATA_ENDING_2","PROC_INST","PROC_INST_BODY","PROC_INST_QUOTED","PROC_INST_ENDING","OPEN_TAG","OPEN_TAG_SLASH","ATTRIB","ATTRIB_NAME","ATTRIB_NAME_SAW_WHITE","ATTRIB_VALUE","ATTRIB_VALUE_QUOTED","ATTRIB_VALUE_UNQUOTED","ATTRIB_VALUE_ENTITY_Q","ATTRIB_VALUE_ENTITY_U","CLOSE_TAG","CLOSE_TAG_SAW_WHITE","SCRIPT","SCRIPT_ENDING","event","nodeType","textNode","textopts","text","trim","normalize","replace","Error","strictFail","message","newTag","tagName","parent","name","attributes","qname","qualName","prefix","local","attrib","qn","attribName","attribValue","openTag","selfClosing","uri","JSON","stringify","p","nv","toLowerCase","closeTag","t","closeTo","pop","x","n","parseEntity","num","numStr","charAt","slice","parseInt","String","fromCharCode","starti","substring","sgmlDecl","startTagPosition","procInstName","procInstBody","toUpperCase","comment","doctype","body","returnState","buffer","exports"],"mappings":"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","sourcesContent":["// wrapper for non-node envs\n;(function (sax) {\n\nsax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\nsax.SAXParser = SAXParser\nsax.SAXStream = SAXStream\nsax.createStream = createStream\n\n// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n// since that's the earliest that a buffer overrun could occur.  This way, checks are\n// as rare as required, but as often as necessary to ensure never crossing this bound.\n// Furthermore, buffers are only tested at most once per write(), so passing a very\n// large string into write() might have undesirable effects, but this is manageable by\n// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n// edge case, result in creating at most one complete copy of the string passed in.\n// Set to Infinity to have unlimited buffers.\nsax.MAX_BUFFER_LENGTH = 64 * 1024\n\nvar buffers = [\n  \"comment\", \"sgmlDecl\", \"textNode\", \"tagName\", \"doctype\",\n  \"procInstName\", \"procInstBody\", \"entity\", \"attribName\",\n  \"attribValue\", \"cdata\", \"script\"\n]\n\nsax.EVENTS = // for discoverability.\n  [ \"text\"\n  , \"processinginstruction\"\n  , \"sgmldeclaration\"\n  , \"doctype\"\n  , \"comment\"\n  , \"attribute\"\n  , \"opentag\"\n  , \"closetag\"\n  , \"opencdata\"\n  , \"cdata\"\n  , \"closecdata\"\n  , \"error\"\n  , \"end\"\n  , \"ready\"\n  , \"script\"\n  , \"opennamespace\"\n  , \"closenamespace\"\n  ]\n\nfunction SAXParser (strict, opt) {\n  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)\n\n  var parser = this\n  clearBuffers(parser)\n  parser.q = parser.c = \"\"\n  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n  parser.opt = opt || {}\n  parser.tagCase = parser.opt.lowercasetags ? \"toLowerCase\" : \"toUpperCase\"\n  parser.tags = []\n  parser.closed = parser.closedRoot = parser.sawRoot = false\n  parser.tag = parser.error = null\n  parser.strict = !!strict\n  parser.noscript = !!(strict || parser.opt.noscript)\n  parser.state = S.BEGIN\n  parser.ENTITIES = Object.create(sax.ENTITIES)\n  parser.attribList = []\n\n  // namespaces form a prototype chain.\n  // it always points at the current tag,\n  // which protos to its parent tag.\n  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)\n\n  // mostly just for error reporting\n  parser.position = parser.line = parser.column = 0\n  emit(parser, \"onready\")\n}\n\nif (!Object.create) Object.create = function (o) {\n  function f () { this.__proto__ = o }\n  f.prototype = o\n  return new f\n}\n\nif (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {\n  return o.__proto__\n}\n\nif (!Object.keys) Object.keys = function (o) {\n  var a = []\n  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n  return a\n}\n\nfunction checkBufferLength (parser) {\n  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    , maxActual = 0\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    var len = parser[buffers[i]].length\n    if (len > maxAllowed) {\n      // Text/cdata nodes can get big, and since they're buffered,\n      // we can get here under normal conditions.\n      // Avoid issues by emitting the text node now,\n      // so at least it won't get any bigger.\n      switch (buffers[i]) {\n        case \"textNode\":\n          closeText(parser)\n        break\n\n        case \"cdata\":\n          emitNode(parser, \"oncdata\", parser.cdata)\n          parser.cdata = \"\"\n        break\n\n        case \"script\":\n          emitNode(parser, \"onscript\", parser.script)\n          parser.script = \"\"\n        break\n\n        default:\n          error(parser, \"Max buffer length exceeded: \"+buffers[i])\n      }\n    }\n    maxActual = Math.max(maxActual, len)\n  }\n  // schedule the next check for the earliest possible buffer overrun.\n  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)\n                             + parser.position\n}\n\nfunction clearBuffers (parser) {\n  for (var i = 0, l = buffers.length; i < l; i ++) {\n    parser[buffers[i]] = \"\"\n  }\n}\n\nSAXParser.prototype =\n  { end: function () { end(this) }\n  , write: write\n  , resume: function () { this.error = null; return this }\n  , close: function () { return this.write(null) }\n  , end: function () { return this.write(null) }\n  }\n\ntry {\n  var Stream = require(\"stream\").Stream\n} catch (ex) {\n  var Stream = function () {}\n}\n\n\nvar streamWraps = sax.EVENTS.filter(function (ev) {\n  return ev !== \"error\" && ev !== \"end\"\n})\n\nfunction createStream (strict, opt) {\n  return new SAXStream(strict, opt)\n}\n\nfunction SAXStream (strict, opt) {\n  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)\n\n  Stream.apply(me)\n\n  this._parser = new SAXParser(strict, opt)\n  this.writable = true\n  this.readable = true\n\n\n  var me = this\n\n  this._parser.onend = function () {\n    me.emit(\"end\")\n  }\n\n  this._parser.onerror = function (er) {\n    me.emit(\"error\", er)\n\n    // if didn't throw, then means error was handled.\n    // go ahead and clear error, so we can write again.\n    me._parser.error = null\n  }\n\n  streamWraps.forEach(function (ev) {\n    Object.defineProperty(me, \"on\" + ev, {\n      get: function () { return me._parser[\"on\" + ev] },\n      set: function (h) {\n        if (!h) {\n          me.removeAllListeners(ev)\n          return me._parser[\"on\"+ev] = h\n        }\n        me.on(ev, h)\n      },\n      enumerable: true,\n      configurable: false\n    })\n  })\n}\n\nSAXStream.prototype = Object.create(Stream.prototype,\n  { constructor: { value: SAXStream } })\n\nSAXStream.prototype.write = function (data) {\n  this._parser.write(data.toString())\n  this.emit(\"data\", data)\n  return true\n}\n\nSAXStream.prototype.end = function (chunk) {\n  if (chunk && chunk.length) this._parser.write(chunk.toString())\n  this._parser.end()\n  return true\n}\n\nSAXStream.prototype.on = function (ev, handler) {\n  var me = this\n  if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n    me._parser[\"on\"+ev] = function () {\n      var args = arguments.length === 1 ? [arguments[0]]\n               : Array.apply(null, arguments)\n      args.splice(0, 0, ev)\n      me.emit.apply(me, args)\n    }\n  }\n\n  return Stream.prototype.on.call(me, ev, handler)\n}\n\n\n\n// character classes and tokens\nvar whitespace = \"\\r\\n\\t \"\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  , number = \"0124356789\"\n  , letter = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  // (Letter | \"_\" | \":\")\n  , nameStart = letter+\"_:\"\n  , nameBody = nameStart+number+\"-.\"\n  , quote = \"'\\\"\"\n  , entity = number+letter+\"#\"\n  , attribEnd = whitespace + \">\"\n  , CDATA = \"[CDATA[\"\n  , DOCTYPE = \"DOCTYPE\"\n  , XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\n  , XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\n  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n// turn all the string character sets into character class objects.\nwhitespace = charClass(whitespace)\nnumber = charClass(number)\nletter = charClass(letter)\nnameStart = charClass(nameStart)\nnameBody = charClass(nameBody)\nquote = charClass(quote)\nentity = charClass(entity)\nattribEnd = charClass(attribEnd)\n\nfunction charClass (str) {\n  return str.split(\"\").reduce(function (s, c) {\n    s[c] = true\n    return s\n  }, {})\n}\n\nfunction is (charclass, c) {\n  return charclass[c]\n}\n\nfunction not (charclass, c) {\n  return !charclass[c]\n}\n\nvar S = 0\nsax.STATE =\n{ BEGIN                     : S++\n, TEXT                      : S++ // general stuff\n, TEXT_ENTITY               : S++ // &amp and such.\n, OPEN_WAKA                 : S++ // <\n, SGML_DECL                 : S++ // <!BLARG\n, SGML_DECL_QUOTED          : S++ // <!BLARG foo \"bar\n, DOCTYPE                   : S++ // <!DOCTYPE\n, DOCTYPE_QUOTED            : S++ // <!DOCTYPE \"//blah\n, DOCTYPE_DTD               : S++ // <!DOCTYPE \"//blah\" [ ...\n, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE \"//blah\" [ \"foo\n, COMMENT_STARTING          : S++ // <!-\n, COMMENT                   : S++ // <!--\n, COMMENT_ENDING            : S++ // <!-- blah -\n, COMMENT_ENDED             : S++ // <!-- blah --\n, CDATA                     : S++ // <![CDATA[ something\n, CDATA_ENDING              : S++ // ]\n, CDATA_ENDING_2            : S++ // ]]\n, PROC_INST                 : S++ // <?hi\n, PROC_INST_BODY            : S++ // <?hi there\n, PROC_INST_QUOTED          : S++ // <?hi \"there\n, PROC_INST_ENDING          : S++ // <?hi \"there\" ?\n, OPEN_TAG                  : S++ // <strong\n, OPEN_TAG_SLASH            : S++ // <strong /\n, ATTRIB                    : S++ // <a\n, ATTRIB_NAME               : S++ // <a foo\n, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _\n, ATTRIB_VALUE              : S++ // <a foo=\n, ATTRIB_VALUE_QUOTED       : S++ // <a foo=\"bar\n, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar\n, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar=\"&quot;\"\n, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;\n, CLOSE_TAG                 : S++ // </a\n, CLOSE_TAG_SAW_WHITE       : S++ // </a   >\n, SCRIPT                    : S++ // <script> ...\n, SCRIPT_ENDING             : S++ // <script> ... <\n}\n\nsax.ENTITIES =\n{ \"apos\" : \"'\"\n, \"quot\" : \"\\\"\"\n, \"amp\"  : \"&\"\n, \"gt\"   : \">\"\n, \"lt\"   : \"<\"\n}\n\nfor (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S\n\n// shorthand\nS = sax.STATE\n\nfunction emit (parser, event, data) {\n  parser[event] && parser[event](data)\n}\n\nfunction emitNode (parser, nodeType, data) {\n  if (parser.textNode) closeText(parser)\n  emit(parser, nodeType, data)\n}\n\nfunction closeText (parser) {\n  parser.textNode = textopts(parser.opt, parser.textNode)\n  if (parser.textNode) emit(parser, \"ontext\", parser.textNode)\n  parser.textNode = \"\"\n}\n\nfunction textopts (opt, text) {\n  if (opt.trim) text = text.trim()\n  if (opt.normalize) text = text.replace(/\\s+/g, \" \")\n  return text\n}\n\nfunction error (parser, er) {\n  closeText(parser)\n  er += \"\\nLine: \"+parser.line+\n        \"\\nColumn: \"+parser.column+\n        \"\\nChar: \"+parser.c\n  er = new Error(er)\n  parser.error = er\n  emit(parser, \"onerror\", er)\n  return parser\n}\n\nfunction end (parser) {\n  if (parser.state !== S.TEXT) error(parser, \"Unexpected end\")\n  closeText(parser)\n  parser.c = \"\"\n  parser.closed = true\n  emit(parser, \"onend\")\n  SAXParser.call(parser, parser.strict, parser.opt)\n  return parser\n}\n\nfunction strictFail (parser, message) {\n  if (parser.strict) error(parser, message)\n}\n\nfunction newTag (parser) {\n  if (!parser.strict) parser.tagName = parser.tagName[parser.tagCase]()\n  var parent = parser.tags[parser.tags.length - 1] || parser\n    , tag = parser.tag = { name : parser.tagName, attributes : {} }\n\n  // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n  if (parser.opt.xmlns) tag.ns = parent.ns\n  parser.attribList.length = 0\n}\n\nfunction qname (name) {\n  var i = name.indexOf(\":\")\n    , qualName = i < 0 ? [ \"\", name ] : name.split(\":\")\n    , prefix = qualName[0]\n    , local = qualName[1]\n\n  // <x \"xmlns\"=\"http://foo\">\n  if (name === \"xmlns\") {\n    prefix = \"xmlns\"\n    local = \"\"\n  }\n\n  return { prefix: prefix, local: local }\n}\n\nfunction attrib (parser) {\n  if (parser.opt.xmlns) {\n    var qn = qname(parser.attribName)\n      , prefix = qn.prefix\n      , local = qn.local\n\n    if (prefix === \"xmlns\") {\n      // namespace binding attribute; push the binding into scope\n      if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n        strictFail( parser\n                  , \"xml: prefix must be bound to \" + XML_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else if (local === \"xmlns\" && parser.attribValue !== XMLNS_NAMESPACE) {\n        strictFail( parser\n                  , \"xmlns: prefix must be bound to \" + XMLNS_NAMESPACE + \"\\n\"\n                  + \"Actual: \" + parser.attribValue )\n      } else {\n        var tag = parser.tag\n          , parent = parser.tags[parser.tags.length - 1] || parser\n        if (tag.ns === parent.ns) {\n          tag.ns = Object.create(parent.ns)\n        }\n        tag.ns[local] = parser.attribValue\n      }\n    }\n\n    // defer onattribute events until all attributes have been seen\n    // so any new bindings can take effect; preserve attribute order\n    // so deferred events can be emitted in document order\n    parser.attribList.push([parser.attribName, parser.attribValue])\n  } else {\n    // in non-xmlns mode, we can emit the event right away\n    parser.tag.attributes[parser.attribName] = parser.attribValue\n    emitNode( parser\n            , \"onattribute\"\n            , { name: parser.attribName\n              , value: parser.attribValue } )\n  }\n\n  parser.attribName = parser.attribValue = \"\"\n}\n\nfunction openTag (parser, selfClosing) {\n  if (parser.opt.xmlns) {\n    // emit namespace binding events\n    var tag = parser.tag\n\n    // add namespace info to tag\n    var qn = qname(parser.tagName)\n    tag.prefix = qn.prefix\n    tag.local = qn.local\n    tag.uri = tag.ns[qn.prefix] || qn.prefix\n\n    if (tag.prefix && !tag.uri) {\n      strictFail(parser, \"Unbound namespace prefix: \"\n                       + JSON.stringify(parser.tagName))\n    }\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (tag.ns && parent.ns !== tag.ns) {\n      Object.keys(tag.ns).forEach(function (p) {\n        emitNode( parser\n                , \"onopennamespace\"\n                , { prefix: p , uri: tag.ns[p] } )\n      })\n    }\n\n    // handle deferred onattribute events\n    for (var i = 0, l = parser.attribList.length; i < l; i ++) {\n      var nv = parser.attribList[i]\n      var name = nv[0]\n        , value = nv[1]\n        , qualName = qname(name)\n        , prefix = qualName.prefix\n        , local = qualName.local\n        , uri = tag.ns[prefix] || \"\"\n        , a = { name: name\n              , value: value\n              , prefix: prefix\n              , local: local\n              , uri: uri\n              }\n\n      // if there's any attributes with an undefined namespace,\n      // then fail on them now.\n      if (prefix && prefix != \"xmlns\" && !uri) {\n        strictFail(parser, \"Unbound namespace prefix: \"\n                         + JSON.stringify(prefix))\n        a.uri = prefix\n      }\n      parser.tag.attributes[name] = a\n      emitNode(parser, \"onattribute\", a)\n    }\n    parser.attribList.length = 0\n  }\n\n  // process the tag\n  parser.sawRoot = true\n  parser.tags.push(parser.tag)\n  emitNode(parser, \"onopentag\", parser.tag)\n  if (!selfClosing) {\n    // special case for <script> in non-strict mode.\n    if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n      parser.state = S.SCRIPT\n    } else {\n      parser.state = S.TEXT\n    }\n    parser.tag = null\n    parser.tagName = \"\"\n  }\n  parser.attribName = parser.attribValue = \"\"\n  parser.attribList.length = 0\n}\n\nfunction closeTag (parser) {\n  if (!parser.tagName) {\n    strictFail(parser, \"Weird empty close tag.\")\n    parser.textNode += \"</>\"\n    parser.state = S.TEXT\n    return\n  }\n  // first make sure that the closing tag actually exists.\n  // <a><b></c></b></a> will close everything, otherwise.\n  var t = parser.tags.length\n  var tagName = parser.tagName\n  if (!parser.strict) tagName = tagName[parser.tagCase]()\n  var closeTo = tagName\n  while (t --) {\n    var close = parser.tags[t]\n    if (close.name !== closeTo) {\n      // fail the first time in strict mode\n      strictFail(parser, \"Unexpected close tag\")\n    } else break\n  }\n\n  // didn't find it.  we already failed for strict, so just abort.\n  if (t < 0) {\n    strictFail(parser, \"Unmatched closing tag: \"+parser.tagName)\n    parser.textNode += \"</\" + parser.tagName + \">\"\n    parser.state = S.TEXT\n    return\n  }\n  parser.tagName = tagName\n  var s = parser.tags.length\n  while (s --> t) {\n    var tag = parser.tag = parser.tags.pop()\n    parser.tagName = parser.tag.name\n    emitNode(parser, \"onclosetag\", parser.tagName)\n\n    var x = {}\n    for (var i in tag.ns) x[i] = tag.ns[i]\n\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    if (parser.opt.xmlns && tag.ns !== parent.ns) {\n      // remove namespace bindings introduced by tag\n      Object.keys(tag.ns).forEach(function (p) {\n        var n = tag.ns[p]\n        emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n })\n      })\n    }\n  }\n  if (t === 0) parser.closedRoot = true\n  parser.tagName = parser.attribValue = parser.attribName = \"\"\n  parser.attribList.length = 0\n  parser.state = S.TEXT\n}\n\nfunction parseEntity (parser) {\n  var entity = parser.entity.toLowerCase()\n    , num\n    , numStr = \"\"\n  if (parser.ENTITIES[entity]) return parser.ENTITIES[entity]\n  if (entity.charAt(0) === \"#\") {\n    if (entity.charAt(1) === \"x\") {\n      entity = entity.slice(2)\n      num = parseInt(entity, 16)\n      numStr = num.toString(16)\n    } else {\n      entity = entity.slice(1)\n      num = parseInt(entity, 10)\n      numStr = num.toString(10)\n    }\n  }\n  entity = entity.replace(/^0+/, \"\")\n  if (numStr.toLowerCase() !== entity) {\n    strictFail(parser, \"Invalid character entity\")\n    return \"&\"+parser.entity + \";\"\n  }\n  return String.fromCharCode(num)\n}\n\nfunction write (chunk) {\n  var parser = this\n  if (this.error) throw this.error\n  if (parser.closed) return error(parser,\n    \"Cannot write after close. Assign an onready handler.\")\n  if (chunk === null) return end(parser)\n  var i = 0, c = \"\"\n  while (parser.c = c = chunk.charAt(i++)) {\n    parser.position ++\n    if (c === \"\\n\") {\n      parser.line ++\n      parser.column = 0\n    } else parser.column ++\n    switch (parser.state) {\n\n      case S.BEGIN:\n        if (c === \"<\") parser.state = S.OPEN_WAKA\n        else if (not(whitespace,c)) {\n          // have to process this as a text node.\n          // weird, but happens.\n          strictFail(parser, \"Non-whitespace before first tag.\")\n          parser.textNode = c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.TEXT:\n        if (parser.sawRoot && !parser.closedRoot) {\n          var starti = i-1\n          while (c && c!==\"<\" && c!==\"&\") {\n            c = chunk.charAt(i++)\n            if (c) {\n              parser.position ++\n              if (c === \"\\n\") {\n                parser.line ++\n                parser.column = 0\n              } else parser.column ++\n            }\n          }\n          parser.textNode += chunk.substring(starti, i-1)\n        }\n        if (c === \"<\") parser.state = S.OPEN_WAKA\n        else {\n          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))\n            strictFail(\"Text data outside of root node.\")\n          if (c === \"&\") parser.state = S.TEXT_ENTITY\n          else parser.textNode += c\n        }\n      continue\n\n      case S.SCRIPT:\n        // only non-strict\n        if (c === \"<\") {\n          parser.state = S.SCRIPT_ENDING\n        } else parser.script += c\n      continue\n\n      case S.SCRIPT_ENDING:\n        if (c === \"/\") {\n          emitNode(parser, \"onscript\", parser.script)\n          parser.state = S.CLOSE_TAG\n          parser.script = \"\"\n          parser.tagName = \"\"\n        } else {\n          parser.script += \"<\" + c\n          parser.state = S.SCRIPT\n        }\n      continue\n\n      case S.OPEN_WAKA:\n        // either a /, ?, !, or text is coming next.\n        if (c === \"!\") {\n          parser.state = S.SGML_DECL\n          parser.sgmlDecl = \"\"\n        } else if (is(whitespace, c)) {\n          // wait for it...\n        } else if (is(nameStart,c)) {\n          parser.startTagPosition = parser.position - 1\n          parser.state = S.OPEN_TAG\n          parser.tagName = c\n        } else if (c === \"/\") {\n          parser.startTagPosition = parser.position - 1\n          parser.state = S.CLOSE_TAG\n          parser.tagName = \"\"\n        } else if (c === \"?\") {\n          parser.state = S.PROC_INST\n          parser.procInstName = parser.procInstBody = \"\"\n        } else {\n          strictFail(parser, \"Unencoded <\")\n          parser.textNode += \"<\" + c\n          parser.state = S.TEXT\n        }\n      continue\n\n      case S.SGML_DECL:\n        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {\n          emitNode(parser, \"onopencdata\")\n          parser.state = S.CDATA\n          parser.sgmlDecl = \"\"\n          parser.cdata = \"\"\n        } else if (parser.sgmlDecl+c === \"--\") {\n          parser.state = S.COMMENT\n          parser.comment = \"\"\n          parser.sgmlDecl = \"\"\n        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {\n          parser.state = S.DOCTYPE\n          if (parser.doctype || parser.sawRoot) strictFail(parser,\n            \"Inappropriately located doctype declaration\")\n          parser.doctype = \"\"\n          parser.sgmlDecl = \"\"\n        } else if (c === \">\") {\n          emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl)\n          parser.sgmlDecl = \"\"\n          parser.state = S.TEXT\n        } else if (is(quote, c)) {\n          parser.state = S.SGML_DECL_QUOTED\n          parser.sgmlDecl += c\n        } else parser.sgmlDecl += c\n      continue\n\n      case S.SGML_DECL_QUOTED:\n        if (c === parser.q) {\n          parser.state = S.SGML_DECL\n          parser.q = \"\"\n        }\n        parser.sgmlDecl += c\n      continue\n\n      case S.DOCTYPE:\n        if (c === \">\") {\n          parser.state = S.TEXT\n          emitNode(parser, \"ondoctype\", parser.doctype)\n          parser.doctype = true // just remember that we saw it.\n        } else {\n          parser.doctype += c\n          if (c === \"[\") parser.state = S.DOCTYPE_DTD\n          else if (is(quote, c)) {\n            parser.state = S.DOCTYPE_QUOTED\n            parser.q = c\n          }\n        }\n      continue\n\n      case S.DOCTYPE_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.q = \"\"\n          parser.state = S.DOCTYPE\n        }\n      continue\n\n      case S.DOCTYPE_DTD:\n        parser.doctype += c\n        if (c === \"]\") parser.state = S.DOCTYPE\n        else if (is(quote,c)) {\n          parser.state = S.DOCTYPE_DTD_QUOTED\n          parser.q = c\n        }\n      continue\n\n      case S.DOCTYPE_DTD_QUOTED:\n        parser.doctype += c\n        if (c === parser.q) {\n          parser.state = S.DOCTYPE_DTD\n          parser.q = \"\"\n        }\n      continue\n\n      case S.COMMENT:\n        if (c === \"-\") parser.state = S.COMMENT_ENDING\n        else parser.comment += c\n      continue\n\n      case S.COMMENT_ENDING:\n        if (c === \"-\") {\n          parser.state = S.COMMENT_ENDED\n          parser.comment = textopts(parser.opt, parser.comment)\n          if (parser.comment) emitNode(parser, \"oncomment\", parser.comment)\n          parser.comment = \"\"\n        } else {\n          parser.comment += \"-\" + c\n          parser.state = S.COMMENT\n        }\n      continue\n\n      case S.COMMENT_ENDED:\n        if (c !== \">\") {\n          strictFail(parser, \"Malformed comment\")\n          // allow <!-- blah -- bloo --> in non-strict mode,\n          // which is a comment of \" blah -- bloo \"\n          parser.comment += \"--\" + c\n          parser.state = S.COMMENT\n        } else parser.state = S.TEXT\n      continue\n\n      case S.CDATA:\n        if (c === \"]\") parser.state = S.CDATA_ENDING\n        else parser.cdata += c\n      continue\n\n      case S.CDATA_ENDING:\n        if (c === \"]\") parser.state = S.CDATA_ENDING_2\n        else {\n          parser.cdata += \"]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.CDATA_ENDING_2:\n        if (c === \">\") {\n          if (parser.cdata) emitNode(parser, \"oncdata\", parser.cdata)\n          emitNode(parser, \"onclosecdata\")\n          parser.cdata = \"\"\n          parser.state = S.TEXT\n        } else if (c === \"]\") {\n          parser.cdata += \"]\"\n        } else {\n          parser.cdata += \"]]\" + c\n          parser.state = S.CDATA\n        }\n      continue\n\n      case S.PROC_INST:\n        if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY\n        else parser.procInstName += c\n      continue\n\n      case S.PROC_INST_BODY:\n        if (!parser.procInstBody && is(whitespace, c)) continue\n        else if (c === \"?\") parser.state = S.PROC_INST_ENDING\n        else if (is(quote, c)) {\n          parser.state = S.PROC_INST_QUOTED\n          parser.q = c\n          parser.procInstBody += c\n        } else parser.procInstBody += c\n      continue\n\n      case S.PROC_INST_ENDING:\n        if (c === \">\") {\n          emitNode(parser, \"onprocessinginstruction\", {\n            name : parser.procInstName,\n            body : parser.procInstBody\n          })\n          parser.procInstName = parser.procInstBody = \"\"\n          parser.state = S.TEXT\n        } else {\n          parser.procInstBody += \"?\" + c\n          parser.state = S.PROC_INST_BODY\n        }\n      continue\n\n      case S.PROC_INST_QUOTED:\n        parser.procInstBody += c\n        if (c === parser.q) {\n          parser.state = S.PROC_INST_BODY\n          parser.q = \"\"\n        }\n      continue\n\n      case S.OPEN_TAG:\n        if (is(nameBody, c)) parser.tagName += c\n        else {\n          newTag(parser)\n          if (c === \">\") openTag(parser)\n          else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n          else {\n            if (not(whitespace, c)) strictFail(\n              parser, \"Invalid character in tag name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.OPEN_TAG_SLASH:\n        if (c === \">\") {\n          openTag(parser, true)\n          closeTag(parser)\n        } else {\n          strictFail(parser, \"Forward-slash in opening tag not followed by >\")\n          parser.state = S.ATTRIB\n        }\n      continue\n\n      case S.ATTRIB:\n        // haven't read the attribute name yet.\n        if (is(whitespace, c)) continue\n        else if (c === \">\") openTag(parser)\n        else if (c === \"/\") parser.state = S.OPEN_TAG_SLASH\n        else if (is(nameStart, c)) {\n          parser.attribName = c\n          parser.attribValue = \"\"\n          parser.state = S.ATTRIB_NAME\n        } else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE\n        else if (is(nameBody, c)) parser.attribName += c\n        else strictFail(parser, \"Invalid attribute name\")\n      continue\n\n      case S.ATTRIB_NAME_SAW_WHITE:\n        if (c === \"=\") parser.state = S.ATTRIB_VALUE\n        else if (is(whitespace, c)) continue\n        else {\n          strictFail(parser, \"Attribute without value\")\n          parser.tag.attributes[parser.attribName] = \"\"\n          parser.attribValue = \"\"\n          emitNode(parser, \"onattribute\",\n                   { name : parser.attribName, value : \"\" })\n          parser.attribName = \"\"\n          if (c === \">\") openTag(parser)\n          else if (is(nameStart, c)) {\n            parser.attribName = c\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, \"Invalid attribute name\")\n            parser.state = S.ATTRIB\n          }\n        }\n      continue\n\n      case S.ATTRIB_VALUE:\n        if (is(whitespace, c)) continue\n        else if (is(quote, c)) {\n          parser.q = c\n          parser.state = S.ATTRIB_VALUE_QUOTED\n        } else {\n          strictFail(parser, \"Unquoted attribute value\")\n          parser.state = S.ATTRIB_VALUE_UNQUOTED\n          parser.attribValue = c\n        }\n      continue\n\n      case S.ATTRIB_VALUE_QUOTED:\n        if (c !== parser.q) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_Q\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        parser.q = \"\"\n        parser.state = S.ATTRIB\n      continue\n\n      case S.ATTRIB_VALUE_UNQUOTED:\n        if (not(attribEnd,c)) {\n          if (c === \"&\") parser.state = S.ATTRIB_VALUE_ENTITY_U\n          else parser.attribValue += c\n          continue\n        }\n        attrib(parser)\n        if (c === \">\") openTag(parser)\n        else parser.state = S.ATTRIB\n      continue\n\n      case S.CLOSE_TAG:\n        if (!parser.tagName) {\n          if (is(whitespace, c)) continue\n          else if (not(nameStart, c)) strictFail(parser,\n            \"Invalid tagname in closing tag.\")\n          else parser.tagName = c\n        }\n        else if (c === \">\") closeTag(parser)\n        else if (is(nameBody, c)) parser.tagName += c\n        else {\n          if (not(whitespace, c)) strictFail(parser,\n            \"Invalid tagname in closing tag\")\n          parser.state = S.CLOSE_TAG_SAW_WHITE\n        }\n      continue\n\n      case S.CLOSE_TAG_SAW_WHITE:\n        if (is(whitespace, c)) continue\n        if (c === \">\") closeTag(parser)\n        else strictFail(\"Invalid characters in closing tag\")\n      continue\n\n      case S.TEXT_ENTITY:\n      case S.ATTRIB_VALUE_ENTITY_Q:\n      case S.ATTRIB_VALUE_ENTITY_U:\n        switch(parser.state) {\n          case S.TEXT_ENTITY:\n            var returnState = S.TEXT, buffer = \"textNode\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_Q:\n            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = \"attribValue\"\n          break\n\n          case S.ATTRIB_VALUE_ENTITY_U:\n            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = \"attribValue\"\n          break\n        }\n        if (c === \";\") {\n          parser[buffer] += parseEntity(parser)\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n        else if (is(entity, c)) parser.entity += c\n        else {\n          strictFail(\"Invalid character entity\")\n          parser[buffer] += \"&\" + parser.entity + c\n          parser.entity = \"\"\n          parser.state = returnState\n        }\n      continue\n\n      default:\n        throw new Error(parser, \"Unknown state: \" + parser.state)\n    }\n  } // while\n  // cdata blocks can get very big under normal conditions. emit and move on.\n  // if (parser.state === S.CDATA && parser.cdata) {\n  //   emitNode(parser, \"oncdata\", parser.cdata)\n  //   parser.cdata = \"\"\n  // }\n  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)\n  return parser\n}\n\n})(typeof exports === \"undefined\" ? sax = {} : exports)\n"]},"metadata":{},"sourceType":"script"}