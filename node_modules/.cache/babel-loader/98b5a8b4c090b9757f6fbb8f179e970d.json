{"ast":null,"code":"/*!*/\n// Copyright 2012 Splunk, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n(function () {\n  \"use strict\";\n\n  var utils = require('./utils');\n\n  var root = exports || this;\n  /**\n   * Provides utilities for asynchronous control flow and collection handling.\n   *\n   * @module splunkjs.Async\n   */\n\n  /**\n   * Runs an asynchronous `while` loop.\n   *\n   * @example\n   *      \n   *      var i = 0;\n   *      Async.whilst(\n   *          function() { return i++ < 3; },\n   *          function(done) {\n   *              Async.sleep(0, function() { done(); });\n   *          },\n   *          function(err) {\n   *              console.log(i) // == 3;\n   *          }\n   *      );\n   *\n   * @param {Function} condition A function that returns a _boolean_ indicating whether the condition has been met.\n   * @param {Function} body A function that runs the body of the loop: `(done)`.\n   * @param {Function} callback The function to call when the loop is complete: `(err)`.\n   *\n   * @function splunkjs.Async\n   */\n\n  root.whilst = function (condition, body, callback) {\n    condition = condition || function () {\n      return false;\n    };\n\n    body = body || function (done) {\n      done();\n    };\n\n    callback = callback || function () {};\n\n    var iterationDone = function (err) {\n      if (err) {\n        callback(err);\n      } else {\n        root.whilst(condition, body, callback);\n      }\n    };\n\n    if (condition()) {\n      body(iterationDone);\n    } else {\n      callback(null);\n    }\n  };\n  /**\n   * Runs multiple functions (tasks) in parallel. \n   * Each task takes the callback function as a parameter. \n   * When all tasks have been completed or if an error occurs, the callback \n   * function is called with the combined results of all tasks. \n   *\n   * **Note**: Tasks might not be run in the same order as they appear in the array,\n   * but the results will be returned in that order. \n   *\n   * @example\n   *      \n   *      Async.parallel([\n   *          function(done) {\n   *              done(null, 1);\n   *          },\n   *          function(done) {\n   *              done(null, 2, 3);\n   *          }],\n   *          function(err, one, two) {\n   *              console.log(err); // == null\n   *              console.log(one); // == 1\n   *              console.log(two); // == [1,2]\n   *          }\n   *      );\n   *\n   * @param {Function} tasks An array of functions: `(done)`.\n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, ...)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.parallel = function (tasks, callback) {\n    // Allow for just a list of functions\n    if (arguments.length > 1 && utils.isFunction(arguments[0])) {\n      var args = utils.toArray(arguments);\n      tasks = args.slice(0, args.length - 1);\n      callback = args[args.length - 1];\n    }\n\n    tasks = tasks || [];\n\n    callback = callback || function () {};\n\n    if (tasks.length === 0) {\n      callback();\n    }\n\n    var tasksLeft = tasks.length;\n    var results = [];\n\n    var doneCallback = function (idx) {\n      return function (err) {\n        if (err) {\n          if (callback) {\n            callback(err);\n          }\n\n          callback = null;\n        } else {\n          var args = utils.toArray(arguments);\n          args.shift();\n\n          if (args.length === 1) {\n            args = args[0];\n          }\n\n          results[idx] = args;\n\n          if (--tasksLeft === 0) {\n            results.unshift(null);\n\n            if (callback) {\n              callback.apply(null, results);\n            }\n          }\n        }\n      };\n    };\n\n    for (var i = 0; i < tasks.length; i++) {\n      var task = tasks[i];\n      task(doneCallback(i));\n    }\n  };\n  /**\n   * Runs multiple functions (tasks) in series. \n   * Each task takes the callback function as a parameter. \n   * When all tasks have been completed or if an error occurs, the callback \n   * function is called with the combined results of all tasks in the order\n   * they were run. \n   *\n   * @example\n   *      \n   *      var keeper = 0;\n   *      Async.series([\n   *          function(done) {\n   *              Async.sleep(10, function() {\n   *                  console.log(keeper++); // == 0\n   *                  done(null, 1);\n   *              });\n   *          },\n   *          function(done) {\n   *              console.log(keeper++); // == 1\n   *              done(null, 2, 3);\n   *          }],\n   *          function(err, one, two) {\n   *              console.log(err); // == null\n   *              console.log(one); // == 1\n   *              console.log(two); // == [1,2]\n   *          }\n   *      );\n   *\n   * @param {Function} tasks An array of functions: `(done)`.\n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, ...)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.series = function (tasks, callback) {\n    // Allow for just a list of functions\n    if (arguments.length > 1 && utils.isFunction(arguments[0])) {\n      var args = utils.toArray(arguments);\n      tasks = args.slice(0, args.length - 1);\n      callback = args[args.length - 1];\n    }\n\n    tasks = tasks || [];\n\n    callback = callback || function () {};\n\n    var innerSeries = function (task, restOfTasks, resultsSoFar, callback) {\n      if (!task) {\n        resultsSoFar.unshift(null);\n        callback.apply(null, resultsSoFar);\n        return;\n      }\n\n      task(function (err) {\n        if (err) {\n          if (callback) {\n            callback(err);\n          }\n\n          callback = null;\n        } else {\n          var args = utils.toArray(arguments);\n          args.shift();\n\n          if (args.length === 1) {\n            args = args[0];\n          }\n\n          resultsSoFar.push(args);\n          innerSeries(restOfTasks[0], restOfTasks.slice(1), resultsSoFar, callback);\n        }\n      });\n    };\n\n    innerSeries(tasks[0], tasks.slice(1), [], callback);\n  };\n  /**\n   * Runs an asynchronous function (mapping it) over each element in an array, in parallel.\n   * When all tasks have been completed or if an error occurs, a callback\n   * function is called with the resulting array.\n   *\n   * @example\n   *      \n   *      Async.parallelMap(\n   *          [1, 2, 3],\n   *          function(val, idx, done) { \n   *              if (val === 2) {\n   *                  Async.sleep(100, function() { done(null, val+1); });   \n   *              }\n   *              else {\n   *                  done(null, val + 1);\n   *              }\n   *          },\n   *          function(err, vals) {\n   *              console.log(vals); // == [2,3,4]\n   *          }\n   *      );\n   *\n   * @param {Array} vals An array of values.\n   * @param {Function} fn A function (possibly asynchronous) to apply to each element: `(done)`. \n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, mappedVals)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.parallelMap = function (vals, fn, callback) {\n    vals = vals || [];\n\n    callback = callback || function () {};\n\n    var tasks = [];\n\n    var createTask = function (val, idx) {\n      return function (done) {\n        fn(val, idx, done);\n      };\n    };\n\n    for (var i = 0; i < vals.length; i++) {\n      tasks.push(createTask(vals[i], i));\n    }\n\n    root.parallel(tasks, function (err) {\n      if (err) {\n        if (callback) {\n          callback(err);\n        }\n\n        callback = null;\n      } else {\n        var args = utils.toArray(arguments);\n        args.shift();\n        callback(null, args);\n      }\n    });\n  };\n  /**\n   * Runs an asynchronous function (mapping it) over each element in an array, in series.\n   * When all tasks have been completed or if an error occurs, a callback\n   * function is called with the resulting array.\n   *\n   * @example\n   *      \n   *      var keeper = 1;\n   *      Async.seriesMap(\n   *          [1, 2, 3],\n   *          function(val, idx, done) { \n   *              console.log(keeper++); // == 1, then 2, then 3\n   *              done(null, val + 1);\n   *          },\n   *          function(err, vals) {\n   *              console.log(vals); // == [2,3,4];\n   *          }\n   *      );\n   *\n   * @param {Array} vals An array of values.\n   * @param {Function} fn A function (possibly asynchronous) to apply to each element: `(done)`.\n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, mappedVals)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.seriesMap = function (vals, fn, callback) {\n    vals = vals || [];\n\n    callback = callback || function () {};\n\n    var tasks = [];\n\n    var createTask = function (val, idx) {\n      return function (done) {\n        fn(val, idx, done);\n      };\n    };\n\n    for (var i = 0; i < vals.length; i++) {\n      tasks.push(createTask(vals[i], i));\n    }\n\n    root.series(tasks, function (err) {\n      if (err) {\n        if (callback) {\n          callback(err);\n        }\n      } else {\n        var args = utils.toArray(arguments);\n        args.shift();\n        callback(null, args);\n      }\n    });\n  };\n  /**\n   * Applies an asynchronous function over each element in an array, in parallel.\n   * A callback function is called when all tasks have been completed. If an \n   * error occurs, the callback function is called with an error parameter.\n   *\n   * @example\n   *      \n   *      var total = 0;\n   *      Async.parallelEach(\n   *          [1, 2, 3],\n   *          function(val, idx, done) { \n   *              var go = function() {\n   *                  total += val;\n   *                  done();\n   *              };\n   *              \n   *              if (idx === 1) {\n   *                  Async.sleep(100, go);    \n   *              }\n   *              else {\n   *                  go();\n   *              }\n   *          },\n   *          function(err) {\n   *              console.log(total); // == 6\n   *          }\n   *      );\n   *\n   * @param {Array} vals An array of values.\n   * @param {Function} fn A function (possibly asynchronous) to apply to each element: `(done)`.\n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.parallelEach = function (vals, fn, callback) {\n    vals = vals || [];\n\n    callback = callback || function () {};\n\n    root.parallelMap(vals, fn, function (err, result) {\n      callback(err);\n    });\n  };\n  /**\n   * Applies an asynchronous function over each element in an array, in series.\n   * A callback function is called when all tasks have been completed. If an \n   * error occurs, the callback function is called with an error parameter.\n   *\n   * @example\n   *      \n   *      var results = [1, 3, 6];\n   *      var total = 0;\n   *      Async.seriesEach(\n   *          [1, 2, 3],\n   *          function(val, idx, done) { \n   *              total += val;\n   *              console.log(total === results[idx]); //== true\n   *              done();\n   *          },\n   *          function(err) {\n   *              console.log(total); //== 6\n   *          }\n   *      );\n   *\n   * @param {Array} vals An array of values.\n   * @param {Function} fn A function (possibly asynchronous)to apply to each element: `(done)`.\n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.seriesEach = function (vals, fn, callback) {\n    vals = vals || [];\n\n    callback = callback || function () {};\n\n    root.seriesMap(vals, fn, function (err, result) {\n      callback(err);\n    });\n  };\n  /**\n   * Chains asynchronous tasks together by running a function (task) and\n   * passing the results as arguments to the next task. When all tasks have \n   * been completed or if an error occurs, a callback function is called with \n   * the results of the final task.\n   *\n   * Each task takes one or more parameters, depending on the previous task in the chain.\n   * The last parameter is always the function to run when the task is complete.\n   *\n   * `err` arguments are not passed to individual tasks, but are are propagated \n   * to the final callback function.\n   *\n   * @example\n   *      \n   *     Async.chain(\n   *         function(callback) { \n   *             callback(null, 1, 2);\n   *         },\n   *         function(val1, val2, callback) {\n   *             callback(null, val1 + 1);\n   *         },\n   *         function(val1, callback) {\n   *             callback(null, val1 + 1, 5);\n   *         },\n   *         function(err, val1, val2) {\n   *             console.log(val1); //== 3\n   *             console.log(val2); //== 5\n   *         }\n   *     );\n   *     \n   * @param {Function} tasks An array of functions: `(done)`.\n   * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, ...)`.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.chain = function (tasks, callback) {\n    // Allow for just a list of functions\n    if (arguments.length > 1 && utils.isFunction(arguments[0])) {\n      var args = utils.toArray(arguments);\n      tasks = args.slice(0, args.length - 1);\n      callback = args[args.length - 1];\n    }\n\n    tasks = tasks || [];\n\n    callback = callback || function () {};\n\n    if (!tasks.length) {\n      callback();\n    } else {\n      var innerChain = function (task, restOfTasks, result) {\n        var chainCallback = function (err) {\n          if (err) {\n            callback(err);\n\n            callback = function () {};\n          } else {\n            var args = utils.toArray(arguments);\n            args.shift();\n            innerChain(restOfTasks[0], restOfTasks.slice(1), args);\n          }\n        };\n\n        var args = result;\n\n        if (!restOfTasks.length) {\n          args.push(callback);\n        } else {\n          args.push(chainCallback);\n        }\n\n        task.apply(null, args);\n      };\n\n      innerChain(tasks[0], tasks.slice(1), []);\n    }\n  };\n  /**\n   * Runs a function after a delay (a specified timeout period). \n   * The main purpose of this function is to make `setTimeout` adhere to \n   * Node.js-style function signatures.\n   *\n   * @example\n   *      \n   *     Async.sleep(1000, function() { console.log(\"TIMEOUT\");});\n   *     \n   * @param {Number} timeout The timeout period, in milliseconds.\n   * @param {Function} callback The function to call when the timeout occurs.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.sleep = function (timeout, callback) {\n    setTimeout(function () {\n      callback();\n    }, timeout);\n  };\n  /**\n   * Runs a callback function with additional parameters, which are appended to\n   * the parameter list. \n   *\n   * @example\n   *\n   *      var callback = function(a, b) {\n   *          console.log(a); //== 1\n   *          console.log(b); //== 2\n   *      };\n   *      \n   *      var augmented = Async.augment(callback, 2);\n   *      augmented(1);\n   *     \n   * @param {Function} callback The callback function to augment.\n   * @param {Anything...} rest The number of arguments to add.\n   *\n   * @function splunkjs.Async\n   */\n\n\n  root.augment = function (callback) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      var augmentedArgs = Array.prototype.slice.call(arguments);\n\n      for (var i = 0; i < args.length; i++) {\n        augmentedArgs.push(args[i]);\n      }\n\n      callback.apply(null, augmentedArgs);\n    };\n  };\n})();","map":{"version":3,"sources":["/Users/cyfi/Downloads/splunk-sdk-javascript-create-react-app/examples/browser/create-splunk-react-app/node_modules/splunk-sdk/lib/async.js"],"names":["utils","require","root","exports","whilst","condition","body","callback","done","iterationDone","err","parallel","tasks","arguments","length","isFunction","args","toArray","slice","tasksLeft","results","doneCallback","idx","shift","unshift","apply","i","task","series","innerSeries","restOfTasks","resultsSoFar","push","parallelMap","vals","fn","createTask","val","seriesMap","parallelEach","result","seriesEach","chain","innerChain","chainCallback","sleep","timeout","setTimeout","augment","Array","prototype","call","augmentedArgs"],"mappings":"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","sourcesContent":["/*!*/\n// Copyright 2012 Splunk, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n(function() {\n    \"use strict\";\n    \n    var utils = require('./utils');\n    var root = exports || this;\n\n    /**\n     * Provides utilities for asynchronous control flow and collection handling.\n     *\n     * @module splunkjs.Async\n     */\n\n    /**\n     * Runs an asynchronous `while` loop.\n     *\n     * @example\n     *      \n     *      var i = 0;\n     *      Async.whilst(\n     *          function() { return i++ < 3; },\n     *          function(done) {\n     *              Async.sleep(0, function() { done(); });\n     *          },\n     *          function(err) {\n     *              console.log(i) // == 3;\n     *          }\n     *      );\n     *\n     * @param {Function} condition A function that returns a _boolean_ indicating whether the condition has been met.\n     * @param {Function} body A function that runs the body of the loop: `(done)`.\n     * @param {Function} callback The function to call when the loop is complete: `(err)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.whilst = function(condition, body, callback) {  \n        condition = condition || function() { return false; };\n        body = body || function(done) { done(); };\n        callback = callback || function() {};\n        \n        var iterationDone = function(err) {\n            if (err) {\n                callback(err);\n            }\n            else {\n                root.whilst(condition, body, callback);\n            }\n        };\n        \n        if (condition()) {\n            body(iterationDone);\n        }\n        else {\n            callback(null);\n        }\n    };\n    \n    /**\n     * Runs multiple functions (tasks) in parallel. \n     * Each task takes the callback function as a parameter. \n     * When all tasks have been completed or if an error occurs, the callback \n     * function is called with the combined results of all tasks. \n     *\n     * **Note**: Tasks might not be run in the same order as they appear in the array,\n     * but the results will be returned in that order. \n     *\n     * @example\n     *      \n     *      Async.parallel([\n     *          function(done) {\n     *              done(null, 1);\n     *          },\n     *          function(done) {\n     *              done(null, 2, 3);\n     *          }],\n     *          function(err, one, two) {\n     *              console.log(err); // == null\n     *              console.log(one); // == 1\n     *              console.log(two); // == [1,2]\n     *          }\n     *      );\n     *\n     * @param {Function} tasks An array of functions: `(done)`.\n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, ...)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.parallel = function(tasks, callback) {\n        // Allow for just a list of functions\n        if (arguments.length > 1 && utils.isFunction(arguments[0])) {\n            var args = utils.toArray(arguments);\n            tasks = args.slice(0, args.length - 1);\n            callback = args[args.length - 1];\n        }\n        \n        tasks = tasks || [];\n        callback = callback || function() {};\n        \n        if (tasks.length === 0) {\n            callback();\n        }\n        \n        var tasksLeft = tasks.length;\n        var results = [];\n        var doneCallback = function(idx) {\n            return function(err) {\n                \n                if (err) {\n                    if (callback) {\n                        callback(err);\n                    }\n                    callback = null;\n                }\n                else {\n                    var args = utils.toArray(arguments);  \n                    args.shift();\n                    \n                    if (args.length === 1) {\n                        args = args[0];\n                    }\n                    results[idx] = args;\n                    \n                    if ((--tasksLeft) === 0) {\n                        results.unshift(null);\n                        if (callback) {\n                            callback.apply(null, results);\n                        }\n                    }\n                }\n            };\n        };\n        \n        for(var i = 0; i < tasks.length; i++) {\n            var task = tasks[i];\n            task(doneCallback(i));\n        }\n    };\n    \n    /**\n     * Runs multiple functions (tasks) in series. \n     * Each task takes the callback function as a parameter. \n     * When all tasks have been completed or if an error occurs, the callback \n     * function is called with the combined results of all tasks in the order\n     * they were run. \n     *\n     * @example\n     *      \n     *      var keeper = 0;\n     *      Async.series([\n     *          function(done) {\n     *              Async.sleep(10, function() {\n     *                  console.log(keeper++); // == 0\n     *                  done(null, 1);\n     *              });\n     *          },\n     *          function(done) {\n     *              console.log(keeper++); // == 1\n     *              done(null, 2, 3);\n     *          }],\n     *          function(err, one, two) {\n     *              console.log(err); // == null\n     *              console.log(one); // == 1\n     *              console.log(two); // == [1,2]\n     *          }\n     *      );\n     *\n     * @param {Function} tasks An array of functions: `(done)`.\n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, ...)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.series = function(tasks, callback) {\n        // Allow for just a list of functions\n        if (arguments.length > 1 && utils.isFunction(arguments[0])) {\n            var args = utils.toArray(arguments);\n            tasks = args.slice(0, args.length - 1);\n            callback = args[args.length - 1];\n        }\n        \n        tasks = tasks || [];\n        callback = callback || function() {};\n        \n        var innerSeries = function(task, restOfTasks, resultsSoFar, callback) {\n            if (!task) {\n                resultsSoFar.unshift(null);\n                callback.apply(null, resultsSoFar);\n                return;\n            }\n            \n            task(function(err) {\n                if (err) {\n                    if (callback) {\n                        callback(err);\n                    }\n                    callback = null;\n                }\n                else {\n                    var args = utils.toArray(arguments);\n                    args.shift();\n                    if (args.length === 1) {\n                        args = args[0];\n                    }\n                    resultsSoFar.push(args);\n                    \n                    innerSeries(restOfTasks[0], restOfTasks.slice(1), resultsSoFar, callback);\n                }\n            });\n        };\n        \n        innerSeries(tasks[0], tasks.slice(1), [], callback);\n    };\n    \n    /**\n     * Runs an asynchronous function (mapping it) over each element in an array, in parallel.\n     * When all tasks have been completed or if an error occurs, a callback\n     * function is called with the resulting array.\n     *\n     * @example\n     *      \n     *      Async.parallelMap(\n     *          [1, 2, 3],\n     *          function(val, idx, done) { \n     *              if (val === 2) {\n     *                  Async.sleep(100, function() { done(null, val+1); });   \n     *              }\n     *              else {\n     *                  done(null, val + 1);\n     *              }\n     *          },\n     *          function(err, vals) {\n     *              console.log(vals); // == [2,3,4]\n     *          }\n     *      );\n     *\n     * @param {Array} vals An array of values.\n     * @param {Function} fn A function (possibly asynchronous) to apply to each element: `(done)`. \n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, mappedVals)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.parallelMap = function(vals, fn, callback) {     \n        vals = vals || [];\n        callback = callback || function() {};\n        \n        var tasks = [];\n        var createTask = function(val, idx) {\n            return function(done) { fn(val, idx, done); };\n        };\n        \n        for(var i = 0; i < vals.length; i++) {\n            tasks.push(createTask(vals[i], i));\n        }\n        \n        root.parallel(tasks, function(err) {\n            if (err) {\n                if (callback) {\n                    callback(err);\n                }\n                callback = null;\n            }\n            else {\n                var args = utils.toArray(arguments);\n                args.shift();\n                callback(null, args);\n            }\n        });\n    };\n    \n    /**\n     * Runs an asynchronous function (mapping it) over each element in an array, in series.\n     * When all tasks have been completed or if an error occurs, a callback\n     * function is called with the resulting array.\n     *\n     * @example\n     *      \n     *      var keeper = 1;\n     *      Async.seriesMap(\n     *          [1, 2, 3],\n     *          function(val, idx, done) { \n     *              console.log(keeper++); // == 1, then 2, then 3\n     *              done(null, val + 1);\n     *          },\n     *          function(err, vals) {\n     *              console.log(vals); // == [2,3,4];\n     *          }\n     *      );\n     *\n     * @param {Array} vals An array of values.\n     * @param {Function} fn A function (possibly asynchronous) to apply to each element: `(done)`.\n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, mappedVals)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.seriesMap = function(vals, fn, callback) {     \n        vals = vals || [];\n        callback = callback || function() {};\n        \n        var tasks = [];\n        var createTask = function(val, idx) {\n            return function(done) { fn(val, idx, done); };\n        };\n        \n        for(var i = 0; i < vals.length; i++) {\n            tasks.push(createTask(vals[i], i));\n        }\n        \n        root.series(tasks, function(err) {\n            if (err) {\n                if (callback) {\n                    callback(err);\n                }\n            }\n            else {\n                var args = utils.toArray(arguments);\n                args.shift();\n                callback(null, args);\n            }\n        });\n    };\n    \n    /**\n     * Applies an asynchronous function over each element in an array, in parallel.\n     * A callback function is called when all tasks have been completed. If an \n     * error occurs, the callback function is called with an error parameter.\n     *\n     * @example\n     *      \n     *      var total = 0;\n     *      Async.parallelEach(\n     *          [1, 2, 3],\n     *          function(val, idx, done) { \n     *              var go = function() {\n     *                  total += val;\n     *                  done();\n     *              };\n     *              \n     *              if (idx === 1) {\n     *                  Async.sleep(100, go);    \n     *              }\n     *              else {\n     *                  go();\n     *              }\n     *          },\n     *          function(err) {\n     *              console.log(total); // == 6\n     *          }\n     *      );\n     *\n     * @param {Array} vals An array of values.\n     * @param {Function} fn A function (possibly asynchronous) to apply to each element: `(done)`.\n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.parallelEach = function(vals, fn, callback) {  \n        vals = vals || [];   \n        callback = callback || function() {};\n        \n        root.parallelMap(vals, fn, function(err, result) {\n            callback(err); \n        });\n    };\n    \n    /**\n     * Applies an asynchronous function over each element in an array, in series.\n     * A callback function is called when all tasks have been completed. If an \n     * error occurs, the callback function is called with an error parameter.\n     *\n     * @example\n     *      \n     *      var results = [1, 3, 6];\n     *      var total = 0;\n     *      Async.seriesEach(\n     *          [1, 2, 3],\n     *          function(val, idx, done) { \n     *              total += val;\n     *              console.log(total === results[idx]); //== true\n     *              done();\n     *          },\n     *          function(err) {\n     *              console.log(total); //== 6\n     *          }\n     *      );\n     *\n     * @param {Array} vals An array of values.\n     * @param {Function} fn A function (possibly asynchronous)to apply to each element: `(done)`.\n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.seriesEach = function(vals, fn, callback) {    \n        vals = vals || []; \n        callback = callback || function() {};\n        \n        root.seriesMap(vals, fn, function(err, result) {\n            callback(err); \n        });\n    };\n    \n    /**\n     * Chains asynchronous tasks together by running a function (task) and\n     * passing the results as arguments to the next task. When all tasks have \n     * been completed or if an error occurs, a callback function is called with \n     * the results of the final task.\n     *\n     * Each task takes one or more parameters, depending on the previous task in the chain.\n     * The last parameter is always the function to run when the task is complete.\n     *\n     * `err` arguments are not passed to individual tasks, but are are propagated \n     * to the final callback function.\n     *\n     * @example\n     *      \n     *     Async.chain(\n     *         function(callback) { \n     *             callback(null, 1, 2);\n     *         },\n     *         function(val1, val2, callback) {\n     *             callback(null, val1 + 1);\n     *         },\n     *         function(val1, callback) {\n     *             callback(null, val1 + 1, 5);\n     *         },\n     *         function(err, val1, val2) {\n     *             console.log(val1); //== 3\n     *             console.log(val2); //== 5\n     *         }\n     *     );\n     *     \n     * @param {Function} tasks An array of functions: `(done)`.\n     * @param {Function} callback The function to call when all tasks are done or if an error occurred: `(err, ...)`.\n     *\n     * @function splunkjs.Async\n     */\n    root.chain = function(tasks, callback) {\n        // Allow for just a list of functions\n        if (arguments.length > 1 && utils.isFunction(arguments[0])) {\n            var args = utils.toArray(arguments);\n            tasks = args.slice(0, args.length - 1);\n            callback = args[args.length - 1];\n        }\n        \n        tasks = tasks || [];\n        callback = callback || function() {};\n        \n        if (!tasks.length) {\n            callback();\n        }\n        else {\n            var innerChain = function(task, restOfTasks, result) {\n                var chainCallback = function(err) {\n                    if (err) {\n                        callback(err);\n                        callback = function() {};\n                    }\n                    else {\n                        var args = utils.toArray(arguments);\n                        args.shift();\n                        innerChain(restOfTasks[0], restOfTasks.slice(1), args);\n                    }\n                };\n                \n                var args = result;\n                if (!restOfTasks.length) {\n                    args.push(callback);\n                }\n                else {\n                    args.push(chainCallback);\n                }\n                \n                task.apply(null, args);\n            };\n            \n            innerChain(tasks[0], tasks.slice(1), []);\n        }\n    };\n    \n    /**\n     * Runs a function after a delay (a specified timeout period). \n     * The main purpose of this function is to make `setTimeout` adhere to \n     * Node.js-style function signatures.\n     *\n     * @example\n     *      \n     *     Async.sleep(1000, function() { console.log(\"TIMEOUT\");});\n     *     \n     * @param {Number} timeout The timeout period, in milliseconds.\n     * @param {Function} callback The function to call when the timeout occurs.\n     *\n     * @function splunkjs.Async\n     */\n    root.sleep = function(timeout, callback) {\n        setTimeout(function() {\n            callback();   \n        }, timeout);\n    };\n    \n    /**\n     * Runs a callback function with additional parameters, which are appended to\n     * the parameter list. \n     *\n     * @example\n     *\n     *      var callback = function(a, b) {\n     *          console.log(a); //== 1\n     *          console.log(b); //== 2\n     *      };\n     *      \n     *      var augmented = Async.augment(callback, 2);\n     *      augmented(1);\n     *     \n     * @param {Function} callback The callback function to augment.\n     * @param {Anything...} rest The number of arguments to add.\n     *\n     * @function splunkjs.Async\n     */\n    root.augment = function(callback) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function() {\n            var augmentedArgs = Array.prototype.slice.call(arguments);\n            for(var i = 0; i < args.length; i++) {\n              augmentedArgs.push(args[i]);\n            }\n            \n            callback.apply(null, augmentedArgs);\n        };\n    };\n})();"]},"metadata":{},"sourceType":"script"}